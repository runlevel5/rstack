--- a/src/x86/Ginit.c
+++ b/src/x86/Ginit.c
@@ -130,6 +130,14 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
   unw_word_t *addr;
   ucontext_t *uc = ((struct cursor *)arg)->uc;
 
+  if (!uc)
+    {
+      /* uc is NULL during DWARF-based unwinding with DWARF_LOC_TYPE_REG.
+         Return an error since we can't access registers without a ucontext.
+         See: https://github.com/libunwind/libunwind/issues/938 */
+      return -UNW_EBADREG;
+    }
+
   if (unw_is_fpreg (reg))
     goto badreg;
 
@@ -156,6 +164,11 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   ucontext_t *uc = ((struct cursor *)arg)->uc;
   unw_fpreg_t *addr;
 
+  if (!uc)
+    {
+      return -UNW_EBADREG;
+    }
+
   if (!unw_is_fpreg (reg))
     goto badreg;
 
--- a/src/x86/Gos-linux.c
+++ b/src/x86/Gos-linux.c
@@ -252,6 +252,12 @@ x86_r_uc_addr (ucontext_t *uc, int reg)
 {
   void *addr;
 
+  /* uc can be NULL during DWARF-based unwinding when a register is saved
+     in another register (DWARF_WHERE_REG). Return NULL to signal error.
+     See: https://github.com/libunwind/libunwind/issues/938 */
+  if (!uc)
+    return NULL;
+
   switch (reg)
     {
     case UNW_X86_GS:  addr = &uc->uc_mcontext.gregs[REG_GS]; break;
--- a/src/x86_64/Ginit.c
+++ b/src/x86_64/Ginit.c
@@ -184,6 +184,14 @@ access_reg (unw_addr_space_t as, unw_regnum_t reg, unw_word_t *val, int write,
   unw_word_t *addr;
   ucontext_t *uc = ((struct cursor *)arg)->uc;
 
+  if (!uc)
+    {
+      /* uc is NULL during DWARF-based unwinding with DWARF_LOC_TYPE_REG.
+         Return an error since we can't access registers without a ucontext.
+         See: https://github.com/libunwind/libunwind/issues/938 */
+      return -UNW_EBADREG;
+    }
+
   if (unw_is_fpreg (reg))
     goto badreg;
 
@@ -214,6 +222,11 @@ access_fpreg (unw_addr_space_t as, unw_regnum_t reg, unw_fpreg_t *val,
   ucontext_t *uc = ((struct cursor *)arg)->uc;
   unw_fpreg_t *addr;
 
+  if (!uc)
+    {
+      return -UNW_EBADREG;
+    }
+
   if (!unw_is_fpreg (reg))
     goto badreg;
 
--- a/src/x86_64/Gos-linux.c
+++ b/src/x86_64/Gos-linux.c
@@ -106,6 +106,12 @@ x86_64_r_uc_addr (ucontext_t *uc, int reg)
 {
   /* NOTE: common_init() in init.h inlines these for fast path access. */
   void *addr;
+
+  /* uc can be NULL during DWARF-based unwinding when a register is saved
+     in another register (DWARF_WHERE_REG). Return NULL to signal error.
+     See: https://github.com/libunwind/libunwind/issues/938 */
+  if (!uc)
+    return NULL;
 
   switch (reg)
     {
--- a/src/x86_64/init.h
+++ b/src/x86_64/init.h
@@ -27,16 +27,18 @@
 
 #include "unwind_i.h"
 
-/* Avoid a trip to x86_64_r_uc_addr() for purely local initialisation. */
-#if defined UNW_LOCAL_ONLY && defined __linux
-# define REG_INIT_LOC(c, rlc, ruc) \
-    DWARF_LOC ((unw_word_t) &c->uc->uc_mcontext.gregs[REG_ ## ruc], 0)
-
-#elif defined UNW_LOCAL_ONLY && defined __FreeBSD__
+/* Avoid a trip to x86_64_r_uc_addr() for purely local initialisation.
+   DISABLED for Linux: Direct ucontext access crashes when uc is NULL during
+   DWARF-based unwinding with DWARF_WHERE_REG. Always use DWARF_REG_LOC
+   which goes through x86_64_r_uc_addr() with NULL check.
+   See: https://github.com/libunwind/libunwind/issues/938 */
+#if defined UNW_LOCAL_ONLY && defined __FreeBSD__
+/* FreeBSD still uses direct access - may need similar fix if crashes occur */
 # define REG_INIT_LOC(c, rlc, ruc) \
     DWARF_LOC ((unw_word_t) &c->uc->uc_mcontext.mc_ ## rlc, 0)
 
 #else
 # define REG_INIT_LOC(c, rlc, ruc) \
     DWARF_REG_LOC (&c->dwarf, UNW_X86_64_ ## ruc)
 #endif
